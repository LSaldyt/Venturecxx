; Venture library functions

; TODO: many of these functions do their work by converting vectors and arrays
; to lists and back. This is bad for two reasons.
; 1. Converting to lists and back introduces some overhead we don't want
; 2. Right now, we can't tell vectors from arrays so I
; just convert everything back to an array. This could break things, should
; be fixed when vectors and arrays can be told apart.

; check if a list is empty
; Parameters
;   v : list, vector, or array
[assume is_empty
  (lambda (v)
    (if (= (size v) 0)
      true
      false))]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Convert between arrays, lists, and vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Convert an array or vector to a list
; Parameters
;   v : vector or array
[assume to_list
  (lambda (v)
    (_to_list_helper v 0 (size v)))]

; Helper for the above. Needed because no letrec in Venture.
[assume _to_list_helper
  (lambda (v idx n)
    (if (= idx n)
      (list)
      (pair
        (lookup v idx)
        (_to_list_helper v (+ 1 idx) n))))]

; Convert a list to an array
; Parameters
;   v : list
[assume to_array
  (lambda (v)
    (eval
      (pair (quote array) v)
      (get_current_environment)))]

; Convert a list to a vector
; Parameters
;   v : list
[assume to_vector
  (lambda (v)
    (eval
      (pair (quote vector) v)
      (get_current_environment)))]


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Support for functional programming
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Map function over elements of array
; TODO: allow to map over arbitrary number of arrays. Not possible currently.
; Parameters
;   f : function
;   v : list, vector, or array
[assume map
  (lambda (f v)
    (if (is_pair v)
      (_map_list f v)
      (if (is_array v)
        (to_array (_map_list f (to_list v)))
        (to_vector (_map_list f (to_list v))))))]

; Map for lists (same args as above)
[assume _map_list
  (lambda (f v)
    (if (is_empty v)
      (list)
      (pair
        (f (first v))
        (_map_list f (rest v)))))]

; Reduce (mirrors functionality here: http://srfi.schemers.org/srfi-1/srfi-1.html)
; Parameters
;   f : function
;   v : list, vector, or array
;   identity : identity value for the funciont f
[assume reduce
  (lambda (f v identity)
    (if (is_pair v)
      (_reduce_list f v identity)
      (_reduce_list f (to_list v) identity)))]

; Reduce for lists (same args as above)
[assume _reduce_list
  (lambda (f v identity)
    (if (is_empty v)
      identity
      (f (first v) (_reduce_list f (rest v) identity))))]


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Vector / matrix ops
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

[assume dot
  (lambda (x y)
    (if (is_pair x)
      (_dot_list x y)
      (_dot_vector x y 0 (size x))))]

[assume _dot_list
  (lambda (x y)
    (if (is_empty x)
      0
      (+
        (* (first x) (first y))
        (dot (rest x) (rest y)))))]

[assume _dot_vector
  (lambda (x y idx length)
    (if (= idx length)
      0
      (+
        (* (lookup x idx) (lookup y idx))
        (_dot_vector x y (+ 1 idx) length))))]

[assume sum
  (lambda (x)
    (reduce + x 0))]

[assume prod
  (lambda (x)
    (reduce * x 1))]

[assume mean
  (lambda (x)
    (/ (sum x) (size x)))]

; multiply list / array / vector v by scalar k
[assume scalar_mult
  (lambda (v k)
    (map (lambda (x) (* x k)) v))]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Useful math functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Take the negative of a number.
; Parameters
;   x : number
[assume negative
  (lambda (x)
    (* x -1))]

; The logistic (sigmoid) function
; Parameters
;   x : number
[assume logistic
  (lambda (x)
    (/ 1 (+ 1 (exp (negative x)))))]

; The logit (inverse logistic) function
; Parameters
;   x : number
[assume logit
  (lambda (x)
    (log (/ x (- 1 x))))]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Convenience functions for assembling vectors and lists
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Repeat the given value n times, and return as requested type
;Allowed types are vector, list, array
;[sample (repeat 4 7 (quote vector))]
[assume repeat
  (lambda (value n type)
    (if (= type (quote list))
      (_repeat_list_helper value n 0)
      (if (= type (quote array))
        (to_array (_repeat_list_helper value n 0))
        (to_vector (_repeat_list_helper value n 0)))))]

[assume _repeat_list_helper
  (lambda (value n idx)
    (if (= idx n)
      (list)
      (pair value (_repeat_list_helper value n (+ idx 1)))))]

; Construct vector of zeros of a given length n, of given type
; [sample (zeros 3 (quote vector))]
[assume zeros
  (lambda (n type)
    (repeat 0 n type))]

; Construct vector of ones of a given length n, of given type
; [sample (zeros 3 (quote vector))
[assume ones
  (lambda (n type)
    (repeat 0 n type))]

; Range (as Python's range function)
[assume range
  (lambda (start stop type)
    (if (= type (quote list))
      (_range_list start stop)
      (if (= type (quote array))
        (to_array (_range_list start stop))
        (to_vector (_range_list start stop)))))]

[assume _range_list
  (lambda (start stop)
    (let ((incr (if (>= stop start) 1 -1)))
      (if (= start stop)
          (list)
          (pair start (_range_list (+ incr start) stop)))))]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Matrix constructors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Identity matrix of dimension D
[assume eye
  (lambda (D)
    (diag D 1))]

;; Diagonal matrix of dimension D
[assume diag
  (lambda (D diag_value)
    (matrix (_diag_helper D diag_value 0)))]

[assume _diag_helper
  (lambda (D diag_value idx)
    (if (= idx D)
      (list)
      (pair
        (_one_row D diag_value idx)
        (_diag_helper D diag_value (+ idx 1)))))]

; Construct one row of a diagonal matrix.
[assume _one_row
  (lambda (D diag_value fill_position)
    (_one_row_helper D diag_value fill_position 0))]

[assume _one_row_helper
  (lambda (D diag_value fill_position idx)
    (if (= idx D)
      (list)
      (pair
        (if (= idx fill_position) diag_value 0)
        (_one_row_helper D diag_value fill_position (+ idx 1)))))]




