Todo list convention: A '+' bullet means "done"; a "x" bullet means
"will not do (for the immediate goal)".

Things to ship:
- Custom proposal bugs:
  - Define an assess that works on actions
  - Define logDensity for engine_method_sp(foo) that calls
    foo_logDensity, if that method exists
- Venture reference documentation
  - Programmatically generate reasonable descriptions of generic psps?
  - Manually write them instead?
  - Re-link foreigns.rst (and actually finish it?)

----------------------------------------------------------------------

Technical clarification idea: The inference programming language has
support for Markov chains.  Execution histories of models are one
possible kind of state space, but there's really nothing magic about
them (except that they are common enough to deserve supporting
machinery).

Technical clarification idea: Separate the notion of a subproblem
(scaffold) from the notion of a local proposal (the LKernel dict).

- It's called a "local" proposal because it's tied to the structure of
  the subproblem, and can exploit cancellations in the acceptance
  ratio

- It makes sense to have the proposal itself be an object because of
  coordination between the detach and regen phases

- Each subproblem admits a default local proposal (prior resimulation)

- One can construct a local proposal by supplying values for the
  principal nodes and forswearing prior cancellation for them

- Do I want a facility for per-SP customization of the otherwise
  default local proposal?

- This nomenclature does not seem to cover the uses of detach and regen
  to implement complex stories like pgibbs, slice and hmc.

Technical simplification project: The inference program should be able
to export compound procedures to be callable by foreign Python code
(e.g., (lambda (values) detach, regen, report posterior weight)).


----------------------------------------------------------------------

Do the trickiness integration tests pollute some directory with figure
files?  Should the integration test check that those files get
written?

I really should capture the standard output of at least the automatic
tests of the "print" procedure, and maybe even check that it agrees
with expectations.

More bugs:
- Anthony wants a shortcut for mapm over arange
- mapm doesn't work on arrays/vectors

Later:
- Broaden the distributions that the random tester chooses for
  dispatching psps to select uniformly from the alternatives
- Check Jenkins/Flowdock integration -- the Venture Jenkins's backlink seems broken
- Dispatch as written breaks automatic coersion
- rename global_posterior to assess_global_posterior or something like
  that, to avoid name clashing with move to global posterior
- announce reset_to_prior, posterior, run
- Could make prefix ! (exclamation point) be a shortcut for (run foo)

Idea: Do we want to implement vkm's own sequential rejection algorithm
generically for Venture?

----------------------------------------------------------------------

Idea: is there a cogent definition for observe (expr) = number?
- Can try factor (assess number (expr))
  - Problem: assessment of an application expression needs to
    integrate over the possible operators
  - Alternative problem: conditional assessment of an application
    expression has the base measure problem

----------------------------------------------------------------------

A "proposal on X" is a stochastic function X -> R X
  x' ~ q(x'|x)
that also computes the acceptance ratio component
         q(x|x')
beta_q = -------
         q(x'|x)
such that
alpha = beta * p(x)/p(x') is a valid M-H ratio for any target distribution p on x

Proposal combinations - aux-mh:
  start with x
  u  ~ p(u|x)
  u' ~ q(u'|u), beta
  x' ~ r(x'|u')
Intuition is that u is an alternate representation of x, but we will
analyze it as an auxiliary variable in addition to x.
Then the proposal is x -> x', with component
           p(u|x)   q(u|u') r(x|u)
beta_pqr = -------------------------
           p(u'|x') q(u'|u) r(x'|u')

This is a morphism from proposals on X to proposals on U.  Proof
obligation: whenever beta_q is a valid ratio for proposing to U,
beta_pqr is a valid ratio for proposing to X.  Conjecture: this can be
discharged by analyzing u as an auxiliary variable with conditional
distribution p(u|x).

----------------------------------------

Generic proposals, as above, with proposal combinations, form a
category.  It does not obviously have products, though.

----------------------------------------------------------------------

Hakaru's answer to the base measure problem: permit sum measures;
compute base measures statically

----------------------------------------------------------------------

Future:
- Fix egregious introduced discrepancies
  - What should Puma's asExpression produce for strings?
  - Lite's ExpressionType?
  - #39 There appears to be considerable code duplication between the
    church' and VS parsers (e.g., the Trie class?)
  + #63 Can I get rid of the dependency on pyparsing?
  - examples/hmm.vnt is wrong (the current CP solution fixes whatever
    the bug was).
- Crosscat
- Delete things
  - #18, #61, #62 extra parsed directives and support code
  - #56 operator substitution
  - #57 does the core sivm still have _modify ?
  - #58 can I flush the SIVM's observation reporting cache?
- System cleaning
  - Flesh out vectorization by generic operations
    - Stan does this
    - Read numpy's design for inspiration (or matlab?)
  - Fun fact: the infer command is now an alias for the run function,
    except it has its own code path (and supports infer loop).
- Performance (vectorization, partial evaluator, per-family sharing)
- Papers
- High-achiever educational goal: ship standalone self-study document
  we can give interested people to learn Venture
  - Exchangeable coupling chapter (with discrete models?)
  - Maybe LDA chapter
  - Fuller reference manual
- BayesBD integration (metamodel interface, VS metamodels, etc)
