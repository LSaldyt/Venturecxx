iterate = (n, f, a) ~> {
  if (n <= 0) { a } else {
    iterate(n-1, f, f(a))
  }
};

replicate = (n, f) ~> {
  if (n <= 0) { list() } else {
    pair(f(), replicate(n-1, f))
  }
};

range = (n) ~> {
  if (n <= 1) { list(0) } else {
    pair(n-1, range(n-1))
  }
};

replicate2 = sp((args, target, mechanism) ~> {
  n = args[0];
  f = args[1];
  score_box = get_current_trace();
  score_box := 0.0;
  doit = (k) ~> {
    (dscore, ans) = regenerate(f, [], target[k], mechanism[k]);
    score_box := @score_box + dscore;
    ans
  };
  res = map(doit, range(n));
  list(@score_box, res)
});

map = (f, l) -> {
  if (is_pair(l)) {
    pair(f(first(l)), map(f, rest(l)))
  } else {
    list()
  }
};

for_each = (f, l) -> {
  if (is_pair(l)) {
    f(first(l));
    for_each(f, rest(l))
  } else {
    "done"
  }
};

for_each2 = (f, l1, l2) -> {
  if (is_pair(l1) && is_pair(l2)) {
    f(first(l1), first(l2));
    for_each2(f, rest(l1), rest(l2))
  } else {
    "done"
  }
};

trace_of = (sp, args) ~> {
  t1 = get_current_trace();
  t2 = get_current_trace();
  (score, _) = regenerate(sp, args, t1, t2);
  list(score, t2)
};

lookup_chain = (coll, key) -> {
  if (is_pair(key)) {
    lookup_chain(lookup(coll, first(key)), rest(key))
  } else {
    coll
  }
};
