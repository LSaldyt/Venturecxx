regenerator = (args, target, mechanism) -> {
  mu = args[0];
  sig1 = args[1];
  sig2 = args[2];
  if (trace_has(mechanism)) {
    list(0, @mechanism)
  } else { if (trace_has(mechanism["x"])) {
    regenerate(normal, [@mechanism["x"], sig2], target, mechanism)
  } else { // mechanism trace is empty
    if (trace_has(target) && not(trace_has(target["x"]))) {
      prec1 = 1 / (sig1 ** 2);
      prec2 = 1 / (sig2 ** 2);
      post_mu = (mu * prec1 + @target * prec2) / (prec1 + prec2);
      post_prec = prec1 + prec2;
      post_sig = sqrt(1 / post_prec);
      post_sample ~ normal(post_mu, post_sig);
      mechanism["x"] := post_sample;
      regenerate(normal, [mu, sqrt(sig1**2 + sig2**2)],
                 target, mechanism)
  } else {
    (score, val) = regenerate(normal, [mu, sig1], target["x"], mechanism["x"]);
    (score2, val2) = regenerate(normal, [val, sig2], target, mechanism);
    list(score + score2, val2)
  }}}
};

normal_normal = sp(regenerator);
