infer_reject = (sp, args, log_bound, target) ~> {
  t1 = get_current_trace();
  res = regenerate(sp, args, target, t1);
  score = first(res);
  if (log(uniform_continuous(0, 1)) < score - log_bound) {
    t1
  } else {
    infer_reject(sp, args, log_bound, target)
  }
};

infer_resampling = (sp, args, target, num_p) ~> {
  particles = replicate(num_p, () ~> {
    t1 = get_current_trace();
    res = regenerate(sp, args, target, t1);
    score = first(res);
    list(score, t1)
  });
  log_categorical(map(first, particles), map(second, particles))
};

rmh_step = (sp, args, target, init_mech, mech_sites) ~> {
  // Expect the target + mech_sites to form a complete "subproblem",
  // with target acting as the absorbing border and sites acting as
  // the regeneration graph.  If there is a gap between the sites
  // and the target, the weights will come out wrong.
  old_vals = map((s) -> { trace_get(subtrace_at(init_mech, s)) }, mech_sites);
  old_res = regenerate(sp, args, target, init_mech); // Expecting init_mech to be complete
  old_score = first(old_res);
  for_each((s) -> { trace_clear(subtrace_at(init_mech, s)) }, mech_sites);
  new_res = regenerate(sp, args, target, init_mech);
  new_score = first(new_res);
  if (log(uniform_continuous(0, 1)) < new_score - old_score) {
    // Accept
    init_mech
  } else {
    // Reject
    for_each2((s, v) -> { trace_set(subtrace_at(init_mech, s), v) }, mech_sites, old_vals);
    init_mech
  }
};
