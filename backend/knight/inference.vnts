infer_reject = (sp, args, log_bound, target) ~> {
  t1 = get_current_trace();
  res = regenerate(sp, args, target, t1);
  score = first(res);
  if (log(uniform_continuous(0, 1)) < score - log_bound) {
    t1
  } else {
    infer_reject(sp, args, log_bound, target)
  }
};

infer_resampling = (sp, args, target, num_p) ~> {
  particles = replicate(num_p, () ~> {
    t1 = get_current_trace();
    res = regenerate(sp, args, target, t1);
    score = first(res);
    list(score, t1)
  });
  log_categorical(map(first, particles), map(second, particles))
};

rmh_step = (sp, args, target, init_mech, mech_sites) ~> {
  // Expect the target + mech_sites to form a complete "subproblem",
  // with target acting as the absorbing border and sites acting as
  // the regeneration graph.  If there is a gap between the sites
  // and the target, the weights will come out wrong.
  old_vals = map((s) -> { @init_mech[*s] }, mech_sites);
  old_res = regenerate(sp, args, target, init_mech); // Expecting init_mech to be complete
  old_score = first(old_res);
  for_each((s) -> { trace_clear(subtrace_at(init_mech, s)) }, mech_sites);
  new_res = regenerate(sp, args, target, init_mech);
  new_score = first(new_res);
  if (log(uniform_continuous(0, 1)) < new_score - old_score) {
    // Accept
    init_mech
  } else {
    // Reject
    for_each2((s, v) -> { subtrace_at(init_mech, s) := v }, mech_sites, old_vals);
    init_mech
  }
};

ssrmh_step = (sp, args, input_trace, constraint_addresses) ~> {
  candidates = set_difference(trace_sites(input_trace), constraint_addresses);
  site = uniform_categorical(candidates);
  cons1 = get_current_trace();
  cons1 := site;
  res1 = regenerate(uniform_categorical, [candidates], cons1, get_current_trace());
  old_logp = first(res1);
  old_val = @subtrace_at(input_trace, site);
  old_res = regenerate(sp, args, input_trace, get_current_trace());
  old_score = first(old_res);
  trace_clear(subtrace_at(input_trace, site));
  new_res = regenerate(sp, args, input_trace, input_trace);
  new_score = first(new_res);
  new_candidates = set_difference(trace_sites(input_trace), constraint_addresses);
  res2 = regenerate(uniform_categorical, [new_candidates], cons1, get_current_trace());
  new_logp = first(res2);
  if (log(uniform_continuous(0, 1)) < new_score - old_score + old_logp - new_logp) {
    // Accept
    input_trace
  } else {
    // Reject
    subtrace_at(input_trace, site) := old_val;
    input_trace
  }
};

infer_ssrmh = (sp, args, target, num_steps) ~> {
  t2 = get_current_trace();
  regenerate(sp, args, target, t2);
  step = (t) ~> { ssrmh_step(sp, args, t2, trace_sites(target)) };
  iterate(num_steps, step, t2)
};
