infer_reject = (sp, args, target, log_bound) ~> {
  t1 = get_current_trace();
  (score, _) = regenerate(sp, args, target, t1);
  if (log(uniform_continuous(0, 1)) < score - log_bound) {
    t1
  } else {
    infer_reject(sp, args, target, log_bound)
  }
};

infer_resampling = (sp, args, target, num_p) ~> {
  particles = replicate(num_p, () ~> {
    t1 = T{};
    (score, _) = regenerate(sp, args, target, t1);
    (score, t1)
  });
  log_categorical(map(first, particles), map(second, particles))
};

rmh_step = (sp, args, target, init_mech, mech_sites) ~> {
  // Expect the target + mech_sites to form a complete "subproblem",
  // with target acting as the absorbing border and sites acting as
  // the regeneration graph.  If there is a gap between the sites
  // and the target, the weights will come out wrong.
  old_vals = map((s) -> { @init_mech[*s] }, mech_sites);
  (old_score, _) = regenerate(sp, args, target, init_mech); // Expecting init_mech to be complete
  for_each((s) -> { del init_mech[*s] }, mech_sites);
  (new_score, _) = regenerate(sp, args, target, init_mech);
  if (log(uniform_continuous(0, 1)) < new_score - old_score) {
    // Accept
    init_mech
  } else {
    // Reject
    for_each2((s, v) -> { init_mech[*s] := v }, mech_sites, old_vals);
    init_mech
  }
};

ssrmh_step = (sp, args, input_trace, constraint_addresses) ~> {
  candidates = set_difference(trace_sites(input_trace), constraint_addresses);
  site = uniform_categorical(candidates);
  cons1 = T{site};
  (old_logp, _) = regenerate(uniform_categorical, [candidates], cons1, T{});
  old_val = @input_trace[*site];
  (old_score, _) = regenerate(sp, args, input_trace, T{});
  del input_trace[*site];
  (new_score, _) = regenerate(sp, args, input_trace, input_trace);
  new_candidates = set_difference(trace_sites(input_trace), constraint_addresses);
  (new_logp, _) = regenerate(uniform_categorical, [new_candidates], cons1, T{});
  if (log(uniform_continuous(0, 1)) < new_score - old_score + old_logp - new_logp) {
    // Accept
    input_trace
  } else {
    // Reject
    input_trace[*site] := old_val;
    input_trace
  }
};

infer_ssrmh = (sp, args, target, num_steps) ~> {
  t2 = T{};
  regenerate(sp, args, target, t2);
  step = (t) ~> { ssrmh_step(sp, args, t2, trace_sites(target)) };
  iterate(num_steps, step, t2)
};

infer_mcmc = (sp, args, target, num_steps, query) ~> {
  t2 = T{};
  regenerate(sp, args, target, t2);
  first_val = query(t2);
  step = (t) ~> { ssrmh_step(sp, args, t2, trace_sites(target)); query(t2) };
  pair(first_val, map(step, range(num_steps)))
};

infer_rolling_resample = (sp, args, target, num_p, query) ~> {
  particle = () ~> {
    t1 = T{};
    (score, _) = regenerate(sp, args, target, t1);
    (score, t1)
  };
  current = T{ score=-1/0, t=T{} };
  print(current);
  step = () ~> {
    (score, t) = particle();
    weights = [@current["score"], score];
    current["t"] := log_categorical(weights, [@current["t"], t]);
    current["score"] := logsumexp(weights);
    query(@current["t"])
  };
  replicate(num_p, step)
};
