infer_reject = (sp, args, log_bound, target) ~> {
  t1 = get_current_trace();
  res = regenerate(sp, args, target, t1);
  score = first(res);
  if (log(uniform_continuous(0, 1)) < score - log_bound) {
    t1
  } else {
    infer_reject(sp, args, log_bound, target)
  }
};

infer_resampling = (sp, args, target, num_p) ~> {
  particles = replicate(num_p, () ~> {
    t1 = get_current_trace();
    res = regenerate(sp, args, target, t1);
    score = first(res);
    list(score, t1)
  });
  log_categorical(map(first, particles), map(second, particles))
};

rmh_step = (sp, args, target, init_mech, mech_sites) ~> {
  // Expect the target + mech_sites to form a complete "subproblem",
  // with target acting as the absorbing border and sites acting as
  // the regeneration graph.  If there is a gap between the sites
  // and the target, the weights will come out wrong.
  old_vals = map((s) -> { trace_get(subtrace_at(init_mech, s)) }, mech_sites);
  old_res = regenerate(sp, args, target, init_mech); // Expecting init_mech to be complete
  old_score = first(old_res);
  for_each((s) -> { trace_clear(subtrace_at(init_mech, s)) }, mech_sites);
  new_res = regenerate(sp, args, target, init_mech);
  new_score = first(new_res);
  if (log(uniform_continuous(0, 1)) < new_score - old_score) {
    // Accept
    init_mech
  } else {
    // Reject
    for_each2((s, v) -> { trace_set(subtrace_at(init_mech, s), v) }, mech_sites, old_vals);
    init_mech
  }
};

ssrmh_step = (sp, args, input_trace, constraint_addresses) ~> {
  candidates = trace_sites(input_trace) - constraint_addresses;
  site = uniform_choose(candidates);
  cons1 = get_current_trace();
  trace_set(cons1, site);
  res1 = regenerate(uniform_choose, [candidates], cons1, get_current_trace());
  old_logp = first(res1);
  old_val = trace_get(subtrace_at(input_trace, site));
  old_res = regenerate(sp, args, input_trace, get_current_trace());
  old_score = first(old_res);
  trace_clear(subtrace_at(input_trace, site));
  new_res = regenerate(sp, args, input_trace, input_trace);
  new_score = first(new_res);
  new_candidates = trace_sites(input_trace) - constraint_addresses;
  res2 = regenerate(uniform_choose, [new_candidates], cons1, get_current_trace());
  new_logp = first(res2);
  if (log(uniform_continuous(0, 1)) < new_score - old_score + old_logp - new_logp) {
    // Accept
    input_trace
  } else {
    // Reject
    trace_set(subtrace_at(input_trace, site), old_v);
    input_trace
  }
};
