infer_reject = (sp, args, log_bound, target) ~> {
  t1 = get_current_trace();
  (score, _) = regenerate(sp, args, target, t1);
  if (log(uniform_continuous(0, 1)) < score - log_bound) {
    t1
  } else {
    infer_reject(sp, args, log_bound, target)
  }
};

infer_resampling = (sp, args, target, num_p) ~> {
  particles = replicate(num_p, () ~> {
    t1 = get_current_trace();
    (score, _) = regenerate(sp, args, target, t1);
    list(score, t1)
  });
  log_categorical(map(first, particles), map(second, particles))
};

rmh_step = (sp, args, target, init_mech, mech_sites) ~> {
  // Expect the target + mech_sites to form a complete "subproblem",
  // with target acting as the absorbing border and sites acting as
  // the regeneration graph.  If there is a gap between the sites
  // and the target, the weights will come out wrong.
  old_vals = map((s) -> { @init_mech[*s] }, mech_sites);
  (old_score, _) = regenerate(sp, args, target, init_mech); // Expecting init_mech to be complete
  for_each((s) -> { trace_clear(init_mech[*s]) }, mech_sites);
  (new_score, _) = regenerate(sp, args, target, init_mech);
  if (log(uniform_continuous(0, 1)) < new_score - old_score) {
    // Accept
    init_mech
  } else {
    // Reject
    for_each2((s, v) -> { init_mech[*s] := v }, mech_sites, old_vals);
    init_mech
  }
};

ssrmh_step = (sp, args, input_trace, constraint_addresses) ~> {
  candidates = set_difference(trace_sites(input_trace), constraint_addresses);
  site = uniform_categorical(candidates);
  cons1 = get_current_trace();
  cons1 := site;
  (old_logp, _) = regenerate(uniform_categorical, [candidates], cons1, get_current_trace());
  old_val = @input_trace[*site];
  (old_score, _) = regenerate(sp, args, input_trace, get_current_trace());
  trace_clear(input_trace[*site]);
  (new_score, _) = regenerate(sp, args, input_trace, input_trace);
  new_candidates = set_difference(trace_sites(input_trace), constraint_addresses);
  (new_logp, _) = regenerate(uniform_categorical, [new_candidates], cons1, get_current_trace());
  if (log(uniform_continuous(0, 1)) < new_score - old_score + old_logp - new_logp) {
    // Accept
    input_trace
  } else {
    // Reject
    input_trace[*site] := old_val;
    input_trace
  }
};

infer_ssrmh = (sp, args, target, num_steps) ~> {
  t2 = get_current_trace();
  regenerate(sp, args, target, t2);
  step = (t) ~> { ssrmh_step(sp, args, t2, trace_sites(target)) };
  iterate(num_steps, step, t2)
};
