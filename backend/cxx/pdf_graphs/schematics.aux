\relax 
\newlabel{fig:prior_scaffold}{{1(a)}{1}}
\newlabel{sub@fig:prior_scaffold}{{(a)}{1}}
\newlabel{fig:prior_code}{{1(b)}{1}}
\newlabel{sub@fig:prior_code}{{(b)}{1}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces The need to detach first}}{1}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(a)}{\ignorespaces { The result of makeSymDirMult is An SP whose applications are exchangeably coupled. Here the result of one application determines whether or not another application is made. Thus the second application is in the brush of the scaffold generated by the first application. If we do not detach the brush first, we may propose to the first application conditioned on an application that will not exist in the new trace. }}}{1}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(b)}{\ignorespaces { TODO show code }}}{1}}
\newlabel{fig:prior}{{1}{1}}
\newlabel{fig:partition_rho}{{2(a)}{2}}
\newlabel{sub@fig:partition_rho}{{(a)}{2}}
\newlabel{fig:partition_scaffold}{{2(b)}{2}}
\newlabel{sub@fig:partition_scaffold}{{(b)}{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Partitioning the trace along a scaffold}}{2}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(a)}{\ignorespaces { A trace. }}}{2}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(b)}{\ignorespaces { The scaffold partitions the trace into five groups: the nodes that will definitely still exist in the proposal trace but whose values may change (drg), the nodes that we will definitely compute likelihoods at (absorbing), the nodes that may no longer exist (the brush), the parents of nodes in these three groups (parents), and all other nodes which need never be visited at all (ignored). Note that future graphs will not distinguish between these last two groups. }}}{2}}
\newlabel{fig:partition}{{2}{2}}
\newlabel{fig:scaffold_extended}{{3(a)}{3}}
\newlabel{sub@fig:scaffold_extended}{{(a)}{3}}
\newlabel{fig:scaffold_disabled}{{3(b)}{3}}
\newlabel{sub@fig:scaffold_disabled}{{(b)}{3}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces The two stages of constructing a scaffold}}{3}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(a)}{\ignorespaces { To construct a scaffold, we first walk downstream from the principal node, and color gold every node whose value may change, and blue every node at which we can absorb. }}}{3}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(b)}{\ignorespaces { Next, we color green every node that may no longer exist once the gold nodes are resampled. At this point, the red and gold nodes constitute the definite regeneration graph, the blue nodes constitute the absorbing border, and the green nodes constitute the brush. }}}{3}}
\newlabel{fig:scaffold}{{3}{3}}
\newlabel{fig:rer_torus}{{4(a)}{4}}
\newlabel{sub@fig:rer_torus}{{(a)}{4}}
\newlabel{fig:rer_full}{{4(b)}{4}}
\newlabel{sub@fig:rer_full}{{(b)}{4}}
\newlabel{fig:rer}{{}{4}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(a)}{\ignorespaces { A torus with two border nodes. Suppose we regenerate the higher one first, and one of the nodes regenerated makes a simulation request. Regen then hands over control to eval in order to evaluate the expression. (TODO mark the three nodes that have values, and space-permitting have an extra figure to start that just shows the scaffold.) }}}{4}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(b)}{\ignorespaces { Evaluating the expression might involve referencing other nodes in the trace, for example to resolve a variable lookup. Those nodes may be in the drg and may not have been regenerated yet, so eval must hand over control to regen to guarantee that all values have been regenerated before they are used. }}}{4}}
\newlabel{fig:rer_annotated_pdf}{{4(c)}{5}}
\newlabel{sub@fig:rer_annotated_pdf}{{(c)}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Tracking the regen recursions}}{5}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(c)}{\ignorespaces { The same trace as figure \hbox {} with the first-visit order and regeneration order displayed. }}}{5}}
\newlabel{fig:rer_annotated}{{4}{5}}
\newlabel{fig:aaa_basic_no_aaa}{{5(a)}{6}}
\newlabel{sub@fig:aaa_basic_no_aaa}{{(a)}{6}}
\newlabel{fig:aaa_basic_with_aaa}{{5(b)}{6}}
\newlabel{sub@fig:aaa_basic_with_aaa}{{(b)}{6}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Absorbing at applications (AAA)}}{6}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(a)}{\ignorespaces { A large scaffold for sampling a hyperparameter. }}}{6}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(b)}{\ignorespaces { The application of the maker SP computes the log density of all of its applications for us. We say that the maker SP ``absorbs at applications''. }}}{6}}
\newlabel{fig:aaa_basic}{{5}{6}}
\newlabel{fig:aaa_challenge_torus}{{6(a)}{7}}
\newlabel{sub@fig:aaa_challenge_torus}{{(a)}{7}}
\newlabel{fig:aaa_challenge_sub}{{6(b)}{7}}
\newlabel{sub@fig:aaa_challenge_sub}{{(b)}{7}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Challenges with absorbing at applications}}{7}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(a)}{\ignorespaces { A scaffold with three border nodes, one of which is absorbing at applications. The child of the aaa node is a reference to it, and would normally be in the drg. (TODO the extended drg and the extended scaffold should refer to the semantic drg/scaffold, before the aaa shortcut, even though it is never constructed. We should abandon the old use of that term) }}}{7}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(b)}{\ignorespaces { A simulation request may lookup that child before the aaa node has been regenerated, and call regen on it. Regen is normally a no-op for nodes that are not in the drg, but even though the child is not in the drg, it and its parent must be regenerated nonetheless. Thus we need to add the child to the drg dynamically. }}}{7}}
\newlabel{fig:aaa_challenge}{{6}{7}}
\newlabel{fig:order_duality_trace}{{7(a)}{8}}
\newlabel{sub@fig:order_duality_trace}{{(a)}{8}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces The need to detach in the opposite order from how we would have regenerated}}{8}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(a)}{\ignorespaces { A procedure with partial-exchangeable coupling is applied in both the absorbing border and the brush. The probability of the absorbing nodes depends on the order in which we regenerate. As we are detaching, we need to compute the probability of the absorbing nodes that we would have calculated if we had proposed this trace by regenerating along the scaffold. In particular, if we would have visited the absorbing application first during regen, then we must visit it last during detach. We solve this problem by having detach always detach all nodes in the opposite order from how regen would have generated them. (TODO make this a finite collapsed hmm) }}}{8}}
\newlabel{fig:order_duality}{{7}{8}}
