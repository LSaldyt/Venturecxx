;; monad ops from inference prelude

[define bind
  (lambda (act next)
    (inference_action
     (lambda (t)
       (let ((res ((action_func act) t)))
         ((action_func (next (first res))) (rest res))))))]

[define bind_
  (lambda (act next)
    (bind act (lambda (_) (next))))]

[define return
  (lambda (val)
    (inference_action
     (lambda (t) (pair val t))))]

[define copy
  (lambda (state)
    (first (split_trace_func state)))]

[define run_in
  (lambda (act state)
    (let ((result ((action_func act) (copy state))))
      (first result)))]

;; trace interface

[define eval_toplevel
  (lambda (addr expr)
    (do (env <- (global_env))
        (eval_request addr expr env)))]

[define _assume
  (lambda (symbol expr)
    (do (addr <- (next_base_address))
        (eval_toplevel addr expr)
        (bind_global symbol addr)
        (value_at addr)))]

[define _observe
  (lambda (expr value)
    (do (addr <- (next_base_address))
        (eval_toplevel addr expr)
        (register_observation addr value)
        (return 0)))]

[define _predict
  (lambda (expr)
    (do (addr <- (next_base_address))
        (eval_toplevel addr expr)
        (value_at addr)))]
