;; monad ops from inference prelude

[define bind
  (lambda (act next)
    (inference_action
     (lambda (t)
       (let ((res ((action_func act) t)))
         ((action_func (next (first res))) (rest res))))))]

[define bind_
  (lambda (act next)
    (bind act (lambda (_) (next))))]

[define return
  (lambda (val)
    (inference_action
     (lambda (t) (pair val t))))]

[define copy
  (lambda (state)
    (first (split_trace_func state)))]

[define run_in
  (lambda (act state)
    (let ((result ((action_func act) (copy state))))
      (first result)))]

[define with
  (lambda (state act)
    (inference_action
     (lambda (t)
       (let ((result ((action_func act) state)))
         (pair (first result) t)))))]

[define repeat
  (lambda (n act)
    (if (<= n 0)
        (return nil)
        (do act (repeat (- n 1) act))))]

;; trace interface

[define eval_toplevel
  (lambda (addr expr)
    (do (env <- (global_env))
        (eval_request addr expr env)))]

[define _assume
  (lambda (symbol expr)
    (do (addr <- (next_base_address))
        (eval_toplevel addr expr)
        (bind_global symbol addr)
        (value_at addr)))]

[define _observe
  (lambda (expr value)
    (do (addr <- (next_base_address))
        (eval_toplevel addr expr)
        (register_observation addr value)
        (return 0)))]

[define _predict
  (lambda (expr)
    (do (addr <- (next_base_address))
        (eval_toplevel addr expr)
        (value_at addr)))]

;; inference utilities

[define check_consistent
  (lambda ()
    (do (observations <- (get_observations))
        (let loop
            (lambda (loop addrs vals)
              (do (if (is_empty addrs)
                      (return true)
                      (do (let addr (first addrs))
                          (let obs_val (first vals))
                          (cur_val <- (value_at addr))
                          (if (= obs_val cur_val)
                              (loop loop (rest addrs) (rest vals))
                              (return false)))))))
        (loop loop (keys observations) (values observations))))]

[define incorporate_constraint
  (lambda (addr value)
    (do (subproblem <- (single_site_constraint addr value))
        (rev <- (extract subproblem))
        (let trace_frag (rest rev))
        (regen subproblem trace_frag)))]
