;; monad ops from inference prelude

[define bind
  (lambda (act next)
    (inference_action
     (lambda (t)
       (let ((res ((action_func act) t)))
         ((action_func (next (first res))) (rest res))))))]

[define bind_
  (lambda (act next)
    (bind act (lambda (_) (next))))]

[define join
  (lambda (act)
    (bind act (lambda (x) x)))]

[define return
  (lambda (val)
    (inference_action
     (lambda (t) (pair val t))))]

[define copy
  (lambda (state)
    (first (clone_trace_func state)))]

[define run_in
  (lambda (act state)
    ((action_func act) state))]

[define eval_in
  (lambda (act state)
    (let ((result ((action_func act) state)))
      (first result)))]

[define exec_in
  (lambda (act state)
    (let ((result ((action_func act) state)))
      (rest result)))]

[define with
  (lambda (state act)
    (inference_action
     (lambda (t)
       (let ((result ((action_func act) state)))
         (pair (first result) t)))))]

[define repeat
  (lambda (n act)
    (if (<= n 0)
        (return nil)
        (do act (repeat (- n 1) act))))]

[define repeat_timed
  (lambda (n act)
    (do (let af (action_func act))
        (let timed_act
            (inference_action
             (lambda (t)
               (let ((t1 (time))
                     (result (af t))
                     (t2 (time)))
                 (pair (- t2 t1) (rest result))))))
        (let loop
            (lambda (loop n tt)
              (if (<= n 0)
                  (return tt)
                  (do (dt <- timed_act)
                      (loop loop (- n 1) (+ tt dt))))))
        (loop loop n 0)))]

[define accumulate
  (lambda (n address infer_act)
    (do (x <- (value_at address))
        (if (<= n 0)
            (return (list x))
            (do infer_act
                (xs <- (accumulate (- n 1) address infer_act))
                (return (pair x xs))))))]

[define for_each
  (lambda (items f)
    (do (let loop
            (lambda (loop xs)
              (if (is_empty xs)
                  (return nil)
                  (do (y <- (f (first xs)))
                      (ys <- (loop loop (rest xs)))
                      (return (pair y ys))))))
        (loop loop (to_list items))))]

;; trace interface

[define eval_toplevel
  (lambda (addr expr)
    (do (env <- (global_env))
        (eval_request addr expr env)))]

[define _assume
  (lambda (symbol expr)
    (do (addr <- (next_base_address))
        (eval_toplevel addr expr)
        (bind_global symbol addr)
        (value_at addr)))]

[define _observe
  (lambda (expr value)
    (do (addr <- (if (is_symbol expr)
                     (do (env <- (global_env))
                         (find_symbol env expr))
                     (do (addr <- (next_base_address))
                         (eval_toplevel addr expr)
                         (return addr))))
        (register_observation addr value)
        (incorporate_constraint addr value)))]

[define _predict
  (lambda (expr)
    (do (addr <- (next_base_address))
        (eval_toplevel addr expr)
        (value_at addr)))]

[define invoke_metaprogram_of_action_sp
  (lambda (sp name args)
    (join (invoke_metaprogram_of_sp sp name args)))]

;; address literals

[define by_top
  (lambda () 'top)]

[define by_walk
  (lambda (parent index)
    (if (= parent 'top)
	(toplevel index)
	(subexpression index parent)))]

[define r
  (lambda (sp id)
    (request sp id))]

;; inference utilities

[define check_consistent
  (lambda ()
    (do (observations <- (get_observations))
        (let loop
            (lambda (loop addrs vals)
              (do (if (is_empty addrs)
                      (return true)
                      (do (let addr (first addrs))
                          (let obs_val (first vals))
                          (cur_val <- (value_at addr))
                          (if (= obs_val cur_val)
                              (loop loop (rest addrs) (rest vals))
                              (return false)))))))
        (loop loop (keys observations) (values observations))))]

[define single_site_constraint
  (lambda (addr value)
    (do (oper <- (value_at (subexpression 0 addr)))
	(kernel <- (constraint_kernel_of_sp_at addr oper value))
	(subproblem <- (single_site_subproblem_ addr kernel))
	(return subproblem)))]

[define incorporate_constraint
  (lambda (addr value)
    (do (subproblem <- (single_site_constraint addr value))
        (rev <- (extract subproblem))
        (let trace_frag (rest rev))
        (regen subproblem trace_frag)))]

[define random_site_
  (lambda ()
    (make_elementary_sp
     (lambda ()
       (dict
        (array 'state nil)
        (array 'simulate
               (lambda ()
                 (return (_random_site))))
        (array 'log_density_action
               (lambda (site)
                 (return (do (n_sites <- (_num_sites))
                             (return (log n_sites))))))))))]
