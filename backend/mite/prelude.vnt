;; monad ops from inference prelude

[define bind
  (lambda (act next)
    (inference_action
     (lambda (t)
       (let ((res ((action_func act) t)))
         ((action_func (next (first res))) (rest res))))))]

[define bind_
  (lambda (act next)
    (bind act (lambda (_) (next))))]

[define return
  (lambda (val)
    (inference_action
     (lambda (t) (pair val t))))]

[define copy
  (lambda (state)
    (first (clone_trace_func state)))]

[define run_in
  (lambda (act state)
    (let ((result ((action_func act) (copy state))))
      (first result)))]

[define with
  (lambda (state act)
    (inference_action
     (lambda (t)
       (let ((result ((action_func act) state)))
         (pair (first result) t)))))]

[define repeat
  (lambda (n act)
    (if (<= n 0)
        (return nil)
        (do act (repeat (- n 1) act))))]

[define repeat_timed
  (lambda (n act)
    (do (let af (action_func act))
        (let timed_act
            (inference_action
             (lambda (t)
               (let ((t1 (time))
                     (result (af t))
                     (t2 (time)))
                 (pair (- t2 t1) (rest result))))))
        (let loop
            (lambda (loop n tt)
              (if (<= n 0)
                  (return tt)
                  (do (dt <- timed_act)
                      (loop loop (- n 1) (+ tt dt))))))
        (loop loop n 0)))]

[define accumulate
  (lambda (n address infer_act)
    (do (x <- (value_at address))
        (if (<= n 0)
            (return (list x))
            (do infer_act
                (xs <- (accumulate (- n 1) address infer_act))
                (return (pair x xs))))))]

[define for_each
  (lambda (items f)
    (do (let loop
            (lambda (loop xs)
              (if (is_empty xs)
                  (return nil)
                  (do (y <- (f (first xs)))
                      (ys <- (loop loop (rest xs)))
                      (return (pair y ys))))))
        (loop loop (to_list items))))]

;; trace interface

[define eval_toplevel
  (lambda (addr expr)
    (do (env <- (global_env))
        (eval_request addr expr env)))]

[define _assume
  (lambda (symbol expr)
    (do (addr <- (next_base_address))
        (eval_toplevel addr expr)
        (bind_global symbol addr)
        (value_at addr)))]

[define _observe
  (lambda (expr value)
    (do (addr <- (next_base_address))
        (eval_toplevel addr expr)
        (register_observation addr value)
        (return addr)))]

[define _predict
  (lambda (expr)
    (do (addr <- (next_base_address))
        (eval_toplevel addr expr)
        (value_at addr)))]

;; inference utilities

[define check_consistent
  (lambda ()
    (do (observations <- (get_observations))
        (let loop
            (lambda (loop addrs vals)
              (do (if (is_empty addrs)
                      (return true)
                      (do (let addr (first addrs))
                          (let obs_val (first vals))
                          (cur_val <- (value_at addr))
                          (if (= obs_val cur_val)
                              (loop loop (rest addrs) (rest vals))
                              (return false)))))))
        (loop loop (keys observations) (values observations))))]

[define incorporate_constraint
  (lambda (addr value)
    (do (subproblem <- (single_site_constraint addr value))
        (rev <- (extract subproblem))
        (let trace_frag (rest rev))
        (regen subproblem trace_frag)))]

;;; can be used by setting "_observe = incorporating_observe"
[define incorporating_observe
  (lambda (expr value)
    (do (addr <- (_observe expr value))
        (incorporate_constraint addr value)))]
