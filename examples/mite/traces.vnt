;; monad ops from inference prelude

[define bind
  (lambda (act next)
    (inference_action
     (lambda (t)
       (let ((res ((action_func act) t)))
         ((action_func (next (first res))) (rest res))))))]

[define bind_
  (lambda (act next)
    (bind act (lambda (_) (next))))]

[define return
  (lambda (val)
    (inference_action
     (lambda (t) (pair val t))))]

[define run
  (lambda (act state)
    (let ((result ((action_func act) state)))
      (first result)))]

;; trace interface

;; [define blank_trace
;;   (dict (list "counter" "global_env" "results")
;;         (list 0 (get_current_environment) (dict nil nil)))]

[define next_base_address
  (inference_action next_base_address_f)]

[define global_env
  (inference_action global_env_f)]

[define eval_request
  (lambda (addr expr env)
    (inference_action
     (lambda (trace) (eval_request_f trace addr expr env))))]

[define bind_global
  (lambda (symbol addr)
    (inference_action
     (lambda (trace) (bind_global_f trace symbol addr))))]

[define register_observation
  (lambda (addr value)
    (inference_action
     (lambda (trace) (register_observation_f trace addr value))))]

[define check_consistent
  (inference_action check_consistent_f)]

[define split_trace
  (inference_action split_trace_f)]

[define eval_toplevel
  (lambda (addr expr)
    (do (env <- global_env)
        (eval_request addr expr env)))]

[define _assume
  (lambda (symbol expr)
    (do (addr <- next_base_address)
        (eval_toplevel addr expr)
        (bind_global symbol addr)
        (return addr)))]

[define _observe
  (lambda (expr value)
    (do (addr <- next_base_address)
        (eval_toplevel addr expr)
        (register_observation addr value)
        (return addr)))]

[define _predict
  (lambda (expr)
    (do (addr <- next_base_address)
        (eval_toplevel addr expr)
        (return addr)))]

[define example1
  (lambda ()
    (run (do (assume slope (normal 0 1))
             (assume intercept (normal 0 1))
             (assume f (mem (lambda (x) (+ (* slope x) intercept))))
             (predict (debug 'xy (list (f 0) (f 1) (f 2) (f 1)))))
         (blank_trace)))]

[define rejection_loop
  (let ((reset_trace
         (lambda (t) (inference_action (lambda (_) (pair nil t))))))
    (lambda (prog)
      (do (t <- split_trace)
          (result <- prog)
          (consistent <- check_consistent)
          (if consistent
              (return result)
              (do (reset_trace t) (rejection_loop prog))))))]

[define example2
  (lambda ()
    (run (rejection_loop
          (do (assume theta (beta 1 1))
              (observe (flip theta) true)
              (observe (flip theta) true)
              (observe (flip theta) true)
              (observe (flip theta) true)
              (predict (debug 'theta theta))))
         (blank_trace)))]

