[define example1
  (lambda ()
    (run_in (do (assume slope (normal 0 1))
             (assume intercept (normal 0 1))
             (assume f (lambda (x) (+ (* slope x) intercept)))
             (predict (debug 'xy (list (f 0) (f 1) (f 2) (f 1)))))
         (blank_trace)))]

[define split_rejection_loop
  (let ((reset_trace
         (lambda (t) (inference_action (lambda (_) (pair nil t))))))
    (lambda (prog)
      (do (t <- (split_trace))
          (result <- prog)
          (consistent <- (check_consistent))
          (if consistent
              (return result)
              (do (reset_trace t) (split_rejection_loop prog))))))]

[define regen_rejection_loop
  (lambda (prog)
    (do prog
        (let loop
            (lambda (loop)
              (do (s <- (select nil))
                  (rho <- (extract s))
                  (regen s (rest rho))
                  (consistent <- (check_consistent))
                  (if consistent
                      (return nil)
                      (loop loop)))))
        (loop loop)))]

[define example2
  (lambda ()
    (run_in (split_rejection_loop
          (do (assume theta (beta 1 1))
              (observe (flip theta) true)
              (observe (flip theta) true)
              (observe (flip theta) true)
              (observe (flip theta) true)
              (predict (debug 'theta theta))))
         (blank_trace)))]

[define example3
  (lambda ()
    (run_in (split_rejection_loop
          (do (assume theta (beta 1 1))
              (observe (binomial 100 theta) 100)
              (predict (debug 'theta theta))))
         (flat_trace)))]

[define example4
  (lambda ()
    (run_in (do (assume slope (normal 0 1))
                (assume intercept (normal 0 1))
                (assume f (lambda (x) (+ (* slope x) intercept)))
                (predict (debug 'xy (list (f 0) (f 1) (f 2) (f 1))))
                (s <- (select nil))
                (rho <- (extract s))
                (xi <- (regen s (rest rho)))
                (extract s)
                (restore s (rest rho))
                (predict (debug 'xyz (list (f 0) (f 1) (f 2) (f 1))))
                (return (debug 'results (list rho xi))))
            (flat_trace)))]

[define example5
  (lambda ()
    (run_in (regen_rejection_loop
          (do (assume theta (beta 1 1))
              (observe (binomial 100 theta) 100)
              (predict (debug 'theta theta))))
         (flat_trace)))]

[define example6
  (lambda ()
    (run_in (do (assume x (normal 0 1))
                (assume y (normal x 1))
                (x <- (predict x))
                (y <- (predict y))
                (return (debug 'xy (list x y)))
                (s <- (pyselect "{
                         directive(2): {'type': 'proposal'}
                       }"))
                (rho <- (extract s))
                (regen s (rest rho))
                (x <- (predict x))
                (y <- (predict y))
                (return (debug 'xy (list x y)))
                (s <- (pyselect "{
                         directive(1): {'type': 'proposal'},
                         directive(2): {'type': 'proposal'},
                       }"))
                (rho <- (extract s))
                (regen s (rest rho))
                (x <- (predict x))
                (y <- (predict y))
                (return (debug 'xy (list x y))))
            (flat_trace)))]

[define incorporate_constraint
  (lambda (subproblem)
    (do (rev <- (extract subproblem))
        (let trace_frag (rest rev))
        (regen subproblem trace_frag)))]

[define resimulation_step
  (lambda (subproblem)
    (do (rev <- (extract subproblem))
        (let w_rev (first rev))
        (let trace_frag (rest rev))
        (w_fwd <- (regen subproblem trace_frag))
        (consistent <- (check_consistent))
        (if (and consistent (log_flip (- w_fwd w_rev)))
            (return nil)
            (do (extract subproblem)
                (restore subproblem trace_frag)))))]

[define example7
  (lambda ()
    (run_in (do (assume x (normal 0 1))
                (assume y (normal x 1))
                (observe y 4)
                (s <- (pyselectf "{
                         directive(2): {'type': 'constrained',
                                        'val': y}
                       }" (dict (list 'y) (list 4))))
                (weight <- (incorporate_constraint s))
                (return (debug 'weight weight))
                (repeat 100
                  (do (s <- (pyselectf "{
                               directive(1): {'type': 'proposal'},
                               directive(2): {'type': 'constrained',
                                              'val': y}
                             }" (dict (list 'y) (list 4))))
                      (resimulation_step s)
                      (x <- (predict x))
                      (return (debug 'x x)))))
            (flat_trace)))]
