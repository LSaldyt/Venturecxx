;;; beta-binomial as an uncollapsed compound procedure
[define make_beta_binomial
  (lambda (a b)
    (let ((theta (beta a b)))
      (lambda (n) (binomial n theta))))]

;;; using the binomial trace defined in mite.sps.binomial_state
;;; test invoking the trace actions directly
[define example1
  (let ((a 1) (b 1)
        (simulate
         (lambda (n)
           (do (N <- (binomial_N))
               (K <- (binomial_K))
               (let theta (beta (+ a K) (+ b (- N K))))
               (return (binomial n theta)))))
        (incorporate
         (lambda (k n)
           (binomial_add n k)))
        (unincorporate
         (lambda (k n)
           (binomial_remove n k))))
    (lambda ()
      (debug 'results
             (run_in
              (do (x1 <- (simulate 10))
                  (incorporate x1 10)
                  (x2 <- (simulate 10))
                  (incorporate x2 10)
                  (x3 <- (simulate 10))
                  (incorporate x3 10)
                  (x4 <- (simulate 10))
                  (incorporate x4 10)
                  (x5 <- (simulate 10))
                  (incorporate x5 10)
                  (return (+ x1 x2 x3 x4 x5)))
              (binomial_state)))))]

;;; collapsed beta binomial as a simulation procedure
[define make_beta_binomial_s_defn
  '(lambda (a b)
     (make_elementary_sp
      '(lambda (a b)
         (dict
          (list 'trace 'simulate 'incorporate 'unincorporate)
          (list
           trace: (binomial_state)
           simulate:
           (lambda (n)
             (do (N <- (binomial_N))
                 (K <- (binomial_K))
                 (let theta (beta (+ a K) (+ b (- N K))))
                 (return (binomial n theta))))
           incorporate:
           (lambda (k n)
             (binomial_add n k))
           unincorporate:
           (lambda (k n)
             (binomial_remove n k)))))
      a b))]

;;; basic example
[define example2
  (lambda ()
    (run_in
     (do (assume make_beta_binomial_s ,make_beta_binomial_s_defn)
         (assume f (make_beta_binomial_s 1 1))
         (assume x1 (f 10))
         (assume x2 (f 10))
         (assume x3 (f 10))
         (assume x4 (f 10))
         (assume x5 (f 10))
         (result <- (predict (+ x1 x2 x3 x4 x5)))
         (return (debug 'result result)))
     (blank_trace)))]

;;; rejection sampling example
[define rejection
  (lambda ()
    (do (let loop
            (lambda (loop)
              (do (s <- (select nil))
                  (rho <- (extract s))
                  (regen s (rest rho))
                  (consistent <- (check_consistent))
                  (if consistent
                      (return nil)
                      (loop loop)))))
        (loop loop)))]

[define example2b
  (lambda ()
    (run_in
     (do (assume make_beta_binomial_s ,make_beta_binomial_s_defn)
         (assume f (make_beta_binomial_s 1 1))
         (assume y (f 4))
         (assume x (f 1))
         (observe y 4)
         (repeat 10
           (do (rejection)
               (x <- (predict x))
               (return (debug 'x x)))))
     (flat_trace)))]

;;; emulating the binomial trace using the Venture trace

[define v_binomial_state
  (lambda ()
    (run_in
     (do (assume N (poisson 1))
         (assume K (poisson 1))
         (v_binomial_set 0 0)
         (clone_trace))
     (flat_trace)))]

[define v_binomial_set
  (lambda (N K)
    (do (s <- (pyselectf "{
  directive(1): {'type': 'constraint', 'val': N},
  directive(2): {'type': 'constraint', 'val': K}
}" (dict (list 'N 'K) (list N K))))
        (rev <- (extract s))
        (regen s (rest rev))))]

[define v_binomial_N
  (lambda () (predict N))]
[define v_binomial_K
  (lambda () (predict K))]
[define v_binomial_add
  (lambda (n k)
    (do (N <- (predict N))
        (K <- (predict K))
        (v_binomial_set (+ N n) (+ K k))))]
[define v_binomial_remove
  (lambda (n k)
    (do (N <- (predict N))
        (K <- (predict K))
        (v_binomial_set (- N n) (- K k))))]

;;; a version of example1 using the emulated trace
[define example3
  (let ((a 1) (b 1)
        (simulate
         (lambda (n)
           (do (N <- (v_binomial_N))
               (K <- (v_binomial_K))
               (let theta (beta (+ a K) (+ b (- N K))))
               (return (binomial n theta)))))
        (incorporate
         (lambda (k n)
           (v_binomial_add n k)))
        (unincorporate
         (lambda (k n)
           (v_binomial_remove n k))))
    (lambda ()
      (debug 'results
             (run_in
              (do (x1 <- (simulate 10))
                  (incorporate x1 10)
                  (x2 <- (simulate 10))
                  (incorporate x2 10)
                  (x3 <- (simulate 10))
                  (incorporate x3 10)
                  (x4 <- (simulate 10))
                  (incorporate x4 10)
                  (x5 <- (simulate 10))
                  (incorporate x5 10)
                  (return (+ x1 x2 x3 x4 x5)))
              (v_binomial_state)))))]

;;; collapsed beta binomial as a full procedure
[define make_beta_binomial_f_defn
  '(lambda (a b)
     (make_full_sp
      '(lambda (a b)
         (dict
          (list 'trace 'apply 'proposal_kernel)
          (list
           trace: (binomial_state)
           apply:
           (lambda (handle app_id n)
             (do (N <- (binomial_N))
                 (K <- (binomial_K))
                 (let theta (beta (+ a K) (+ b (- N K))))
                 (let k (binomial n theta))
                 (binomial_add n k)
                 (return k)))
           proposal_kernel:
           (lambda (handle app_id)
             (dict
              (list 'extract 'regen 'restore)
              (list
               extract:
               (lambda (k n)
                 (do (binomial_remove n k)
                     (return (pair 0 k))))
               regen:
               (lambda (n)
                 (do (N <- (binomial_N))
                     (K <- (binomial_K))
                     (let theta (beta (+ a K) (+ b (- N K))))
                     (let k (binomial n theta))
                     (binomial_add n k)
                     (return (pair 0 k))))
               restore:
               (lambda (n k)
                 (do (binomial_add n k)
                     (return k)))))))))
      a b))]

;;; basic example
[define example4
  (lambda ()
    (run_in
     (do (assume make_beta_binomial_f ,make_beta_binomial_f_defn)
         (assume f (make_beta_binomial_f 1 1))
         (assume x1 (f 10))
         (assume x2 (f 10))
         (assume x3 (f 10))
         (assume x4 (f 10))
         (assume x5 (f 10))
         (result <- (predict (+ x1 x2 x3 x4 x5)))
         (return (debug 'result result)))
     (blank_trace)))]
