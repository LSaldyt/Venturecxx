;;; beta-binomial as an uncollapsed compound procedure
[define make_beta_binomial
  (lambda (a b)
    (let ((theta (beta a b)))
      (lambda (n) (binomial n theta))))]

;;; using the binomial trace defined in mite.sps.binomial_state
;;; test invoking the trace actions directly
[define example1
  (let ((a 1) (b 1)
        (simulate
         (lambda (n)
           (do (N <- (binomial_N))
               (K <- (binomial_K))
               (let theta (beta (+ a K) (+ b (- N K))))
               (return (binomial n theta)))))
        (incorporate
         (lambda (k n)
           (binomial_add n k)))
        (unincorporate
         (lambda (k n)
           (binomial_remove n k))))
    (lambda ()
      (debug 'results
             (run_in (do (x1 <- (simulate 10))
                         (incorporate x1 10)
                         (x2 <- (simulate 10))
                         (incorporate x2 10)
                         (x3 <- (simulate 10))
                         (incorporate x3 10)
                         (x4 <- (simulate 10))
                         (incorporate x4 10)
                         (x5 <- (simulate 10))
                         (incorporate x5 10)
                         (return (+ x1 x2 x3 x4 x5)))
                     (binomial_state)))))]

;;; utility for wrapping a trace action as an exchangeable procedure
[define make_exchangeable_sp
  (lambda (apply_proc initial_state)
    (let ((state (copy initial_state)))
      (lambda (arg)
        (let ((act (apply_proc arg))
              (result ((action_func act) state)))
          (first result)))))]

;;; collapsed beta binomial as an exchangeable procedure
[define make_beta_binomial_x
  (lambda (a b)
    (make_exchangeable_sp
     (lambda (n)
       (do (N <- (binomial_N))
           (K <- (binomial_K))
           (let theta (beta (+ a K) (+ b (- N K))))
           (let k (binomial n theta))
           (binomial_add n k)
           (return k)))
     (binomial_state)))]

;;; rejection sampling example (with manual rejection loop)
[define example2
  (lambda ()
    (do (let loop
            (lambda (loop n)
              (if (= n 0) nil
                  (let ((f (make_beta_binomial_x 1 1))
                        (y (f 9))
                        (x (f 1)))
                    (if (= y 9)
                        (let ((_ (debug 'x  x)))
                          (loop loop (- n 1)))
                        (loop loop n))))))
        (loop loop 10)))]

;;; emulating the binomial trace using the Venture trace

[define v_binomial_state
  (lambda ()
    (run_in (do (assume N (poisson 1))
                (assume K (poisson 1))
                (v_binomial_set 0 0)
                (split_trace))
            (flat_trace)))]

[define v_binomial_set
  (lambda (N K)
    (do (s <- (pyselectf "{
  directive(1): {'type': 'constrained', 'val': N},
  directive(2): {'type': 'constrained', 'val': K}
}" (dict (list 'N 'K) (list N K))))
        (rev <- (extract s))
        (regen s (rest rev))))]

[define v_binomial_N
  (lambda () (predict N))]
[define v_binomial_K
  (lambda () (predict K))]
[define v_binomial_add
  (lambda (n k)
    (do (N <- (predict N))
        (K <- (predict K))
        (v_binomial_set (+ N n) (+ K k))))]
[define v_binomial_remove
  (lambda (n k)
    (do (N <- (predict N))
        (K <- (predict K))
        (v_binomial_set (- N n) (- K k))))]

;;; a version of example1 using the emulated trace
[define example3
  (let ((a 1) (b 1)
        (simulate
         (lambda (n)
           (do (N <- (v_binomial_N))
               (K <- (v_binomial_K))
               (let theta (beta (+ a K) (+ b (- N K))))
               (return (binomial n theta)))))
        (incorporate
         (lambda (k n)
           (v_binomial_add n k)))
        (unincorporate
         (lambda (k n)
           (v_binomial_remove n k))))
    (lambda ()
      (debug 'results
             (run_in (do (x1 <- (simulate 10))
                         (incorporate x1 10)
                         (x2 <- (simulate 10))
                         (incorporate x2 10)
                         (x3 <- (simulate 10))
                         (incorporate x3 10)
                         (x4 <- (simulate 10))
                         (incorporate x4 10)
                         (x5 <- (simulate 10))
                         (incorporate x5 10)
                         (return (+ x1 x2 x3 x4 x5)))
                     (v_binomial_state)))))]
