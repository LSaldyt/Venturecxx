// Joint simulator for a discrete HMM

define simulate_hmm = (T, O, N) ~> {
  simulate_hmm_lp(T, O, 0, [], [], N);
};

define simulate_hmm_lp = (T, O, prev, states, data, N) ~> {
  if (N == 0) {
    (reverse(states), reverse(data))
  } else {
    next = categorical(row(T, prev));
    out = categorical(row(O, next));
    simulate_hmm_lp(T, O, next, pair(next, states), pair(out, data), N - 1);
  }
};

// Joint assessor for a discrete HMM

// Explicitly does the computation that tracing the state sequence
// and assessing pointwise would have produced.
define assess_hmm = (states, data, T, O, N) -> {
  if (length(states) == length(data) && length(states) == N) {
    assess_hmm_lp(0, states, data, T, O)
  } else {
    0 - infinity
  }
};

define assess_hmm_lp = (prev, states, data, T, O) -> {
  if (is_pair(states)) {
    log_step_p = assess(categorical, first(states), row(T, prev));
    log_out_p = assess(categorical, first(data), row(O, first(states)));
    log_step_p + log_out_p + assess_hmm_lp(first(states), rest(states), rest(data), T, O)
  } else {
    0
  }
};

// Forward filtering computation for a discrete HMM.

// Computes the probability of the data, and an explicit
// representation of the marginal at each time step conditioned on the
// data up to it (inclusive).
define forward_filter = (data, T, O) -> {
  forward_filter_lp(zero_with_prob_1, 0, [], data, T, O)
};

define forward_filter_lp = (prev, data_prob, filtered_probs, data, T, O) -> {
  if (is_pair(data)) {
    candidates = prev * T;
    cur = dot(candidates, col(O, first(data)));
    forward_filter_lp(cur, data_prob + log(sum(cur)), pair(cur, filtered_probs), second(data), T, O)
  } else {
    (data_prob, reverse(filtered_probs))
  }
};

// Simulation from the posterior by backward sampling
define posterior_ffbs_simulator = (data, T, O) -> {
  (_, filtered) = forward_filter(data, T, O);
  rev_filtered = reverse(filtered)
  () ~> {
    last_state ~ categorical(first(rev_filtered));
    posterior_ffbs_sim_lp(list(last_state), rest(rev_filtered), T)
  }
};

define posterior_ffbs_sim_lp = (states, filtered_probs, T) ~> {
  if (is_pair(filtered_probs)) {
    next_state = first(states);
    cur_filtered = first(filtered_probs);
    cur_smoothed = dot(cur_filtered, col(T, next_state));
    cur_state ~ categorical(cur_smoothed);
    posterior_ffbs_sim_lp(pair(cur_state, states), rest(filtered_probs), T)
  } else {
    states
  }
};

// Posterior assessment

// Consists of scaling joint assessment by the probability of the
// data, the latter computed by forward filtering.
define posterior_assessor = (data, T, O) -> {
  (data_prob, _) = forward_filter(data, T, O);
  (states) -> {
    assess_hmm(states, data, T, O, length(data)) - data_prob
  }
};
