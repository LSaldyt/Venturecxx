// Joint simulator for a discrete HMM

define simulate_hmm = (T, O, N) ~> {
  simulate_hmm_lp(T, O, 0, [], [], N);
};

define simulate_hmm_lp = (T, O, prev, states, data, N) ~> {
  if (N == 0) {
    (reverse(states), reverse(data))
  } else {
    next = categorical(row(T, prev));
    out = categorical(row(O, next));
    simulate_hmm_lp(T, O, next, pair(next, states), pair(out, data), N - 1);
  }
};

// Joint assessor for a discrete HMM

// Explicitly does the computation that tracing the state sequence
// and assessing pointwise would have produced.
define assess_hmm = (states, data, T, O, N) -> {
  if (length(states) == length(data) && length(states) == N) {
    assess_hmm_lp(0, states, data, T, O)
  } else {
    0 - infinity
  }
};

define assess_hmm_lp = (prev, states, data, T, O) -> {
  if (is_pair(states)) {
    log_step_p = assess(categorical, first(states), row(T, prev));
    log_out_p = assess(categorical, first(data), row(O, first(states)));
    log_step_p + log_out_p + assess_hmm_lp(first(states), rest(states), rest(data), T, O)
  } else {
    0
  }
};

// Forward filtering computation for a discrete HMM.

// Computes the probability of the data, and an explicit
// representation of the marginal at each time step conditioned on the
// data up to it (inclusive).
define forward_filter = (data, T, O) -> {
  forward_filter_lp(zero_with_prob_1, 0, [], data, T, O)
};

define forward_filter_lp = (prev, data_prob, filtered_probs, data, T, O) -> {
  if (is_pair(data)) {
    candidates = prev * T;
    cur = dot(candidates, col(O, first(data)));
    forward_filter_lp(cur, data_prob + log(sum(cur)), pair(cur, filtered_probs), second(data), T, O)
  } else {
    (data_prob, reverse(filtered_probs))
  }
};
