// define utility procedures
define pass = return(nil);

define make_sp = make_full_sp;

define extract = {
  let old_extract = extract;
  (subproblem) -> {
    package <- old_extract(subproblem);
    return((first(package), rest(package)))
  }
};


define sum = (xs) -> {
  if (is_empty(xs)) { 0 }
  else { first(xs) + sum(rest(xs)) }
};

define resimulation_step = (subproblem) -> {
  package <- extract(subproblem);
  let (old_weight, old_trace_fragment) = package;
  new_weight <- regen(subproblem, old_trace_fragment);
  consistent <- check_consistent();
  if (consistent && log_flip(new_weight - old_weight)) {
    pass
  }
  else {
    extract(subproblem);
    restore(subproblem, old_trace_fragment)
  }
};

// end utility defs

// example usage

define example_beta_bern = (make_beta_bern, infer) -> {
  run_in({
    // import defs from toplevel environment -- remove this in figure
    assume pass = $pass;
    assume make_sp = $make_sp;
    assume extract = $extract;
    assume counter_set = $counter_set;
    assume counter = $counter;
    assume counter_get = $counter_get;
    assume counter_incr = $counter_incr;
    assume counter_decr = $counter_decr;
    // end defs
    assume coin = ${make_beta_bern}(0.5, 0.5);
    let dataset = [
      true, true, true, true, true,
      false, false, true, true,
      false, true, false, true
    ];
    weights <- for_each(dataset, (x) -> {
      infer();
      weight <- { observe coin() = x };
      return (weight)
    });
    return (sum(weights))
  }, flat_trace())
};

// definition as bare compound

define make_beta_bern_lambda = (a, b) -> {
  let theta ~ beta(a, b);
  () ~> {
    flip(theta)
  }
};

define make_beta_bern_lambda_expanded = (a, b) -> {
  let theta ~ beta(a, b);
  let env = get_current_environment();
  make_sp([| (theta) -> {
    let exp = [| flip(theta) |];
    dict(['state', nil],
	 ['apply', (trace_handle, app_id) -> {
	   with(trace_handle, {
	     let extended_env = extend_environment(
	       $env, 'theta', address_of(theta));
	     addr <- request_address(app_id);
	     eval_request(addr, exp, extended_env)
	   })
	 }],
	 ['proposal_kernel', (trace_handle, app_id) -> {
	   return (dict(
	     ['extract', (x) -> {
	       with(trace_handle, {
		 addr <- request_address(app_id);
		 uneval_request(addr);
		 return (pair(0, nil))
	       })
	     }],
	     ['regen', () -> {
	       with(trace_handle, {
		 let extended_env = extend_environment(
		   $env, 'theta', address_of(theta));
		 addr <- request_address(app_id);
		 x <- eval_request(addr, exp, extended_env);
		 return (pair(0, x))
	       })
	     }],
	     ['restore', (_) -> {
	       with(trace_handle, {
		 addr <- request_address(app_id);
		 x <- restore_request(addr);
		 return (x)
	       })
	     }]))
	 }])
  } |], theta)
};

// definition as tail-assessable compound

define make_beta_bern_proc = (a, b) -> {
  let theta ~ beta(a, b);
  proc () {
    flip(theta)
  }
};

define make_beta_bern_proc_expanded = (a, b) -> {
  let theta ~ beta(a, b);
  env = get_current_environment();
  make_sp([| (theta) -> {
    let operator_exp = [| flip |];
    let operand_exp = [| theta |];
    dict(['state', nil],
	 ['apply', (trace_handle, app_id) -> {
	   with(trace_handle, {
	     let extended_env = extend_environment(
	       $env, 'theta', address_of(theta));
	     operator_addr <- request_address(pair(app_id, 0));
	     operand_addr <- request_address(pair(app_id, 1));
	     operator <- eval_request(operator_addr, operator_exp, extended_env);
	     operand <- eval_request(operand_addr, operand_exp, extended_env);
	     result_addr <- request_address(app_id);
	     output <- apply_sp(result_addr, operator, [operand]);
	     return (output)
	   })
	 }],
	 ['proposal_kernel', (trace_handle, app_id) -> {
	   // stubbed
	   return (dict())
	 }],
	 ['constraint_kernel', (trace_handle, app_id, val) -> {
	   return (dict(
	     ['extract', (x) -> {
	       with(trace_handle, {
		 operator_addr <- request_address(pair(app_id, 0));
		 operand_addr <- request_address(pair(app_id, 1));
		 operator <- value_at(operator_addr);
		 operand <- value_at(operand_addr);
		 result_addr <- request_address(app_id);
		 kernel <- constraint_kernel_of_sp_at(result_addr, operator, val);
		 extract_kernel(kernel, x, [operand])
	       })
	     }],
	     ['regen', () -> {
	       with(trace_handle, {
		 operator_addr <- request_address(pair(app_id, 0));
		 operand_addr <- request_address(pair(app_id, 1));
		 operator <- value_at(operator_addr);
		 operand <- value_at(operand_addr);
		 result_addr <- request_address(app_id);
		 kernel <- constraint_kernel_of_sp_at(result_addr, operator, val);
		 regen_kernel(kernel, [operand])
	       })
	     }],
	     ['restore', (trace_fragment) -> {
	       with(trace_handle, {
		 operator_addr <- request_address(pair(app_id, 0));
		 operand_addr <- request_address(pair(app_id, 1));
		 operator <- value_at(operator_addr);
		 operand <- value_at(operand_addr);
		 result_addr <- request_address(app_id);
		 kernel <- constraint_kernel_of_sp_at(result_addr, operator, val);
		 restore_kernel(kernel, [operand], trace_fragment)
	       })
	     }]))
	 }])
  } |], theta)
};

// inference for the tail-assessable compound

define resimulation_infer = () -> {
  // hardcoding the subproblem...
  subproblem <- single_site_subproblem(toplevel(9));
  resimulation_step(subproblem)
};

// inference for the uncollapsed Gibbs variant

define conjugate_gibbs_infer = () -> {
  // call the custom metaprogram
  sp <- value_at(toplevel(9));
  invoke_metaprogram_of_sp(sp, 'infer_latent_conjugate_gibbs', [])
};

// definition as stateful collapsed procedure

define make_beta_bern_collapsed = (a, b) -> {
  make_elementary_sp([| (a, b) -> {
    // import defs from toplevel environment -- remove this in figure
    let pass = $pass;
    let old_extract = extract;
    let extract = $extract;
    let counter_set = $counter_set;
    let counter = $counter;
    let counter_get = $counter_get;
    let counter_incr = $counter_incr;
    let counter_decr = $counter_decr;
    // end defs
    dict(['state', counter(['N', 'K'])],
         ['simulate', () ~> {
           N <- counter_get('N');
           K <- counter_get('K');
           return (flip((a + K) / (a + b + N)))
         }],
         ['log_density', (x) -> {
           N <- counter_get('N');
           K <- counter_get('K');
           let numerator = if (x) { log(a + K) } else { log(b + N - K) };
           let denominator = log(a + b + N);
           return (numerator - denominator)
         }],
         ['incorporate', (x) -> {
           counter_incr('N');
           if (x) { counter_incr('K') } else { pass };
         }],
         ['unincorporate', (x) -> {
           counter_decr('N');
           if (x) { counter_decr('K') } else { pass };
         }])
  } |], a, b)
};

// definition as stateful uncollapsed procedure with Gibbs kernels

define make_beta_bern_uncollapsed = (a, b) -> {
  make_elementary_sp([| (a, b) -> {
    // import defs from toplevel environment -- remove this in figure
    let pass = $pass;
    let old_extract = extract;
    let extract = $extract;
    let counter_set = $counter_set;
    let counter = $counter;
    let counter_get = $counter_get;
    let counter_incr = $counter_incr;
    let counter_decr = $counter_decr;
    // end defs
    dict(['state', counter(['N', 'K', 'theta'])],
         ['initialize', (trace_handle) -> {
           let theta ~ beta(a, b);
           counter_set('theta', theta);
         }],
         ['simulate', () -> {
           theta <- counter_get('theta');
           return (flip(theta))
         }],
         ['log_density', (x) -> {
           theta <- counter_get('theta');
           return (if (x) { log(theta) } else { log(1 - theta) })
         }],
         ['incorporate', (x) -> {
           counter_incr('N');
           if (x) { counter_incr('K') } else { pass };
         }],
         ['unincorporate', (x) -> {
           counter_decr('N');
           if (x) { counter_decr('K') } else { pass };
         }],
         ['infer_latent_conjugate_gibbs', () -> {
           N <- counter_get('N');
           K <- counter_get('K');
           let new_theta ~ beta(a + K, b + N - K);
           counter_set('theta', new_theta);
         }])
  } |], a, b)
};

// supporting definitions

define counter = (keys) -> {
  run_in({
    for_each(keys, (key) -> {
      assume $key = poisson(1);
      counter_set(key, 0)
    });
    clone_trace()
  }, flat_trace())
};

define counter_set = (key, val) -> {
  env <- global_env();
  addr <- find_symbol(env, key);
  set_value_at(addr, val);
};

define counter_get = (key) -> {
  env <- global_env();
  addr <- find_symbol(env, key);
  value_at(addr)
};

define counter_incr = (key) -> {
  val <- counter_get(key);
  counter_set(key, val + 1);
};

define counter_decr = (key) -> {
  val <- counter_get(key);
  counter_set(key, val - 1);
};


// another copy of definition, using foreign counter instead of VS

define make_beta_bern_coll_foreign = (a, b) -> {
  make_elementary_sp([| (a, b) -> {
    // import defs from toplevel environment -- remove this in figure
    let pass = $pass;
    let old_extract = extract;
    let extract = $extract;
    // end defs
    dict(['state', counter()],
         ['simulate', () ~> {
           N <- counter_get('N');
           K <- counter_get('K');
           return (flip((a + K) / (a + b + N)))
         }],
         ['log_density', (x) -> {
           N <- counter_get('N');
           K <- counter_get('K');
           let numerator = if (x) { log(a + K) } else { log(b + N - K) };
           let denominator = log(a + b + N);
           return (numerator - denominator)
         }],
         ['incorporate', (x) -> {
           counter_incr('N');
           if (x) { counter_incr('K') } else { pass };
         }],
         ['unincorporate', (x) -> {
           counter_decr('N');
           if (x) { counter_decr('K') } else { pass };
         }])
  } |], a, b)
};

// definition as stateful uncollapsed procedure with Gibbs kernels

define make_beta_bern_uncoll_foreign = (a, b) -> {
  make_elementary_sp([| (a, b) -> {
    // import defs from toplevel environment -- remove this in figure
    let pass = $pass;
    let old_extract = extract;
    let extract = $extract;
    // end defs
    dict(['state', counter()],
         ['initialize', (trace_handle) -> {
           let theta ~ beta(a, b);
           counter_set('theta', theta);
         }],
         ['simulate', () -> {
           theta <- counter_get('theta');
           return (flip(theta))
         }],
         ['log_density', (x) -> {
           theta <- counter_get('theta');
           return (if (x) { log(theta) } else { log(1 - theta) })
         }],
         ['incorporate', (x) -> {
           counter_incr('N');
           if (x) { counter_incr('K') } else { pass };
         }],
         ['unincorporate', (x) -> {
           counter_decr('N');
           if (x) { counter_decr('K') } else { pass };
         }],
         ['infer_latent_conjugate_gibbs', () -> {
           N <- counter_get('N');
           K <- counter_get('K');
           let new_theta ~ beta(a + K, b + N - K);
           counter_set('theta', new_theta);
         }])
  } |], a, b)
};

