[define mem_defn
  '(lambda (f)
     (make_full_sp
      '(lambda (f)
         (dict
          (array 'state (mem_table))
          (array 'apply
           (lambda (handle app_id x)
             (do (has_value <- (mem_has_value x))
                 (if has_value
                     (do (y <- (mem_lookup x))
                         (mem_incr x)
                         (return y))
                     (do (let exp `(,f ,x))
                         (let env (get_empty_environment)) ; TODO env
                         (y <- (with handle
                           (do (addr <- (new_request x exp env))
                               (value_at addr))))
                         (mem_assoc x y)
                         (mem_incr x)
                         (return y))))))
          (array 'proposal_kernel
           (lambda (handle app_id)
             (dict
              (array 'extract
               (lambda (y x)
                 (do (mem_decr x)
                     (count <- (mem_count x))
                     (if (= count 0)
                         (do (mem_dissoc x)
                             (with handle (free_request x)))
                         (return nil))
                     (return (pair 0 nil)))))
              (array 'regen
               (lambda (x)
                 (do (has_value <- (mem_has_value x))
                     (if has_value
                         (do (y <- (mem_lookup x))
                             (mem_incr x)
                             (return (pair 0 y)))
                         (do (let exp `(,f ,x))
                             (let env (get_empty_environment))
                             ;; TODO should this restore instead?
                             ;; The present definition behaves
                             ;; non-exchangeably in the lightweight
                             ;; setting, because later applications
                             ;; will see earlier applications in the
                             ;; mem table but not vice versa.
                             (y <- (with handle
                                         (do (addr <- (new_request x exp env))
                                             (value_at addr))))
                             (mem_assoc x y)
                             (mem_incr x)
                             (return (pair 0 y)))))))
              (array 'restore
               (lambda (x _)
                 (do (has_value <- (mem_has_value x))
                     (if has_value
                         (do (y <- (mem_lookup x))
                             (mem_incr x)
                             (return y))
                         (do (y <- (with handle
                                         (do (addr <- (restore_request x))
                                             (value_at addr))))
                             (mem_assoc x y)
                             (mem_incr x)
                             (return y)))))))))))
      f))]

;;; basic mem example
[define example1
  (lambda ()
    (run_in
     (do (assume mem ,mem_defn)
         (assume f (mem (lambda (x) (normal 0 1))))
         (result <- (predict (list (f 1) (f 2) (f 3) (f 2) (f 1))))
         (return (debug 'result result)))
     (blank_trace)))]

;;; regen example
[define example2
  (lambda ()
    (run_in
     (do (assume mem ,mem_defn)
         (assume f (mem (lambda (x) (normal 0 1))))
         (assume x1 (f 1))
         (assume x2 (f 2))
         (assume x3 (f 3))
         (assume x4 (f 2))
         (assume x5 (f 1))
         (predict (debug 'result (list x1 x2 x3 x4 x5)))

         (s <- (pyselectf "{
  request(request(directive(1), directive(2)),
          key):
      {'type': 'proposal'}
}" (dict (list 'key) (list 1))))
         (rev <- (extract s))
         (regen s (rest rev))

         (s <- (pyselectf "{
  request(request(directive(1), directive(2)),
          key):
      {'type': 'proposal'}
}" (dict (list 'key) (list 2))))
         (rev <- (extract s))
         (regen s (rest rev))

         (s <- (pyselectf "{
  request(request(directive(1), directive(2)),
          key):
      {'type': 'proposal'}
}" (dict (list 'key) (list 3))))
         (rev <- (extract s))
         (regen s (rest rev)))
     (flat_trace)))]

;;; another regen example

[define example3
  (lambda ()
    (run_in
     (do (assume mem ,mem_defn)
         (assume f (mem (lambda (x) (normal 0 1))))
         (assume x1 (flip))
         (assume x2 (flip))
         (assume y (list (f x1) (f x2)))
         (predict (debug 'result y))

         (s <- (pyselectf "{
  directive(3): {'type': 'constraint', 'val': t},
  directive(4): {'type': 'constraint', 'val': t},
}" (dict (list 't 'f) (list true false))))
         (rev <- (extract s))
         (regen s (rest rev))

         (s <- (pyselectf "{
  directive(3): {'type': 'constraint', 'val': t},
  directive(4): {'type': 'constraint', 'val': f},
}" (dict (list 't 'f) (list true false))))
         (rev <- (extract s))
         (regen s (rest rev))

         (s <- (pyselectf "{
  directive(3): {'type': 'constraint', 'val': f},
  directive(4): {'type': 'constraint', 'val': f},
}" (dict (list 't 'f) (list true false))))
         (rev <- (extract s))
         (regen s (rest rev))

         (s <- (pyselectf "{
  directive(3): {'type': 'constraint', 'val': t},
  directive(4): {'type': 'constraint', 'val': f},
}" (dict (list 't 'f) (list true false))))
         (rev <- (extract s))
         (regen s (rest rev))

         (s <- (pyselectf "{
  directive(3): {'type': 'constraint', 'val': t},
  directive(4): {'type': 'constraint', 'val': t},
}" (dict (list 't 'f) (list true false))))
         (rev <- (extract s))
         (regen s (rest rev)))
     (flat_trace)))]

