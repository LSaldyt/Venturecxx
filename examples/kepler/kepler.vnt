; Copyright (c) 2015 MIT Probabilistic Computing Project.
;
; This file is part of Venture.
;
; Venture is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; Venture is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with Venture.  If not, see <http:;www.gnu.org/licenses/>.

; (load_plugin "kepler.py")
(load_plugin "absorbing_apply.py")

;; Model program ;;

; Kepler's law.
(assume kepler
  (lambda (apogee perigee)
    (let ((GM 398600.4418)
          (earth_radius 6378)
          (a (+ (* .5 (+ (abs apogee) (abs perigee))) earth_radius)))
      (/ (* (* 2 3.1415) (sqrt (/ (pow a 3) GM))) 60))))

; Cluster sampler and assignemnts (z i).
(assume alpha (gamma 2 .5))
(assume sim_cluster (make_crp alpha))
(assume z (mem (lambda (i) (tag i (quote z) (sim_cluster)))))

; Samplers for apogee, perigee cluster c.
; (assume apogee_sampler (mem (lambda (c) (make_nig_normal 1.5e5 1e9 1 20))))
; (assume perigee_sampler (mem (lambda (c) (make_nig_normal 2e4 1e9 1 20))))

(assume sigma2_apogee (mem (lambda (c) (inv_gamma 1 20))))
(assume sigma2_perigee (mem (lambda (c) (inv_gamma 1 20))))

(assume mu_apogee (mem (lambda (c) (normal 1.5e5 (sqrt (* 1e9 (sigma2_apogee c)))))))
(assume mu_perigee (mem (lambda (c) (normal 2e4 (sqrt (* 1e9 (sigma2_perigee c)))))))

; Observations of apogee and perigee for satellite i.
(assume apogee
  (mem (lambda (i)
    (tag i (quote apogee)
      (normal (mu_apogee (z i)) (sqrt (sigma2_apogee (z i))))))))

(assume perigee
  (mem (lambda (i)
    (tag i (quote perigee)
      (normal (mu_perigee (z i)) (sqrt (sigma2_perigee (z i))))))))

; Kepler's law P(T|A,P).
(assume noise (gamma 15 .5))
(assume period
  (mem (lambda (i)
    (tag i (quote period)
      (normal
        (kepler (apogee i) (perigee i))
        noise)))))

; GPM interface commands.
(assume columns (list apogee perigee period))

; Observation process.
[define observer
  (lambda (iapt)
      (let ((sat_id (lookup iapt 0))
            (sat_ap (lookup iapt 1))
            (sat_pg (lookup iapt 2))
            (sat_pr (lookup iapt 3)))
        (do
          (if (< 0 sat_ap)
            (observe (apogee (atom ,sat_id)) sat_ap) pass)
          (if (< 0 sat_pg)
            (observe (perigee (atom ,sat_id)) sat_pg) pass)
          (if (< 0 sat_pr)
            (observe (period (atom ,sat_id)) sat_pr) pass))))]

(pyexec "import pandas as pd; import venture.value.dicts as vd")
(pyexec "from venture.lite.value import VentureValue as VV")
(pyexec "data = pd.read_csv('satellites.csv').itertuples()")

[define n_samples 100]
[define observation
  (lambda () (run (pyeval "VV.fromStackDict(vd.vector(list(data.next())))")))]
(print "Observing")
(for_each (arange n_samples) (lambda (d) (observer (observation))))

; ; Probabilistically invert Kepler's law using single-site MH in local scope.
[define invert_kepler
  (lambda (period_val mh_steps mh_thin n_samples)
    (run
        (do
          (observe (period (atom -1)) period_val foo)
          (repeat 1000
            (do
              (mh (atom -1) 'z 100)
              (hmc (atom -1) all .5 100 50)))
          ; (mh (atom -1) one mh_steps)
          (result <-
            (mapM
              (lambda (k)
                (do
                  (mh (atom -1) one mh_thin)
                  (sample
                    (list (apogee (atom -1))
                          (perigee (atom -1))
                          (kepler (apogee (atom -1))
                                  (perigee (atom -1)))))))
              (arange n_samples)))
          (forget (quote foo))
          (return result))))]

; ; Inference program.
(print "Inferring")
[infer (mh default one 100)]
[define assignments
  (run (mapM (lambda (i) (sample (z (atom ,i)))) (arange n_samples)))]
