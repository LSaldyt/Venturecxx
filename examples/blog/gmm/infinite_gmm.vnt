;; Gaussian mixture model in Venture
;; "Infinite" is not quite right, but that's what BLOG calls it

[assume gaussian (lambda (mu sigma2) (normal mu (sqrt sigma2)))]
[assume to_float (lambda (x) (+ x 0))]

[define setup_gmm
  ;; 1-d Gaussian mixture with an unknown number of components of same weight
  (lambda (component_rep) ; Pass in the way to represent the component representation
    (do
      (assume n_components (poisson 3))
      (assume mu
        (mem (lambda (component)
               (let ((mean_of_means 0)
                     (var_of_means 100))
                 (gaussian mean_of_means var_of_means)))))
      (assume sigma_2
        (mem (lambda (component)
               (let ((alpha 2)
                     (beta 8))
                 (inv_gamma alpha beta)))))
      (component_rep)
      (assume x
        (mem (lambda (obs)
               (let ((c (component_of obs)))
                 (if (= c false)
                     (gaussian 0 1000000)
                     (gaussian (mu c) (sigma_2 c)))))))))]

[define setup_mem_ordered
  ;; Memoization; no birth-death allowed
  (lambda ()
    (do
      (assume component_of
        (mem (lambda (obs)
               (if (= n_components integer<0>)
                   false
                   (to_float (uniform_discrete 0 n_components))))))))]

[define setup_set_ordered
  ;; Sets as list; no birth-death
  (lambda ()
    (do
      (assume components
        (mapv to_float (arange 0 n_components)))
      (assume component_of
        (mem (lambda (obs)
               (if (= n_components integer<0>)
                   false
                   (let ((ix (uniform_discrete 0 n_components)))
                     (lookup components ix))))))))]

[define setup_mem_birth_death
  ;; Memoization with birth-death
  (lambda ()
    (do
      (assume nth_active_iter (lambda (is_active ix component)
                                (if (is_active component)
                                    (if (= ix 0)
                                        component
                                        (nth_active_iter is_active (- ix 1) (+ component 1)))
                                    (nth_active_iter is_active ix (+ component 1)))))
      (assume component_of
        (mem (lambda (obs)
               (let ((is_active (mem (lambda (component) (flip)))))
                 (if (= n_components integer<0>)
                     false
                     (let ((ix (to_float (uniform_discrete 0 n_components))))
                       (nth_active_iter is_active ix 0)))))))))]

[define setup_set_birth_death
  ;; prefix_k with birth-death
  (lambda ()
    (do
      (assume prefix_k
        (lambda (n_components)
          (let ((is_active (mem (lambda (i)
                                  (tag 'is_active i (flip))))))
            (prefix_k_iter is_active (to_float n_components) 0 (list)))))
      (assume prefix_k_iter
        (lambda (is_active k idx set_so_far)
          (if (= (size set_so_far) k)
              set_so_far
              (let ((new_set (if (is_active idx)
                                 (pair idx set_so_far)
                                 set_so_far)))
                (prefix_k_iter is_active k (+ idx 1) new_set)))))
      (assume components (prefix_k n_components))
      (assume component_of
        (mem (lambda (obs)
               (if (= n_components integer<0>)
                   false
                   (let ((ix (uniform_discrete 0 n_components)))
                     (lookup components ix))))))))]
