[define setup
  ;; Problem setup; helper functions and model
  (lambda ()
    (do
      (setup_helper_functions)
      (setup_model)
      ))]

[define setup_helper_functions
  ;; Helper functions for ball / urn problem
  (lambda ()
    (do
      ;; Arithmetic
      (assume abs (lambda (x) (if (> x 0) x (* -1 x))))
      (assume to_float (lambda (x) (+ x 0)))
      ;; prefix_k
      (assume prefix_k
        (lambda (selector k)
          (prefix_k_iter selector
                         (to_float k)
                         0
                         (list))))
      (assume prefix_k_iter
        (lambda (selector k idx set_so_far)
          (if (= (size set_so_far) k)
              set_so_far
              (let ((new_set (if (selector idx)
                                 (pair idx set_so_far)
                                 set_so_far)))
                (prefix_k_iter selector k (+ idx 1) new_set)))))))]

[define setup_model
  ;; The poisson ball / urn model
  (lambda ()
    (do
      ;; The balls in the urn
      (assume n_balls (to_float (poisson 6)))
      (assume balls
        (let ((ball_selector
               (mem (lambda (i)
                      (tag 'selector i (flip))))))
          (prefix_k ball_selector n_balls)))
      ;; mapping from observation to ball
      (assume ball_of
        (mem
          (lambda (obs)
            (if (= n_balls 0)
                -1
                (let ((ix (uniform_discrete 0 n_balls)))
                  (lookup balls ix))))))
      ;; Color switcher
      (assume switch_color
        (lambda (color)
          (if (= color 'Blue)
              'Green
              'Blue)))
      ;; Mapping from ball to 2 colors; not noisy
      (assume color_of
        (mem
          (lambda (ball)
            (if (= ball -1)
                -1
                (categorical (simplex 0.5 0.5)
                             (list 'Blue 'Green))))))
      ;; The colors we actually observe; noisy version of the ball's real colors
      (assume observed_color
        (mem
          (lambda (obs)
            (let ((ball (ball_of obs))
                  (true_color (color_of ball)))
              (if (= true_color -1)
                  -1
                  (if (flip 0.2)
                      (switch_color true_color)
                      true_color))))))
      ))]

;; First comparison to BLOG: observe two balls. Do rejection sampling
[define test_1
  (lambda()
    (do (setup)
        (observe_data)
        (resample_multiprocess 40 40)
        (let ((d (empty)))
          (do (rejection default all 1)
              (bind (collect n_balls) (curry into d))
              (call_back print_this ,d)
              ))))]

[define observe_data
  (lambda ()
    (do (observe (exactly (observed_color 0)) 'Blue)
        (observe (exactly (observed_color 1)) 'Green)))]
